// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Device table API auto-generated by `reggen`

#ifndef OPENTITAN_SW_DEVICE_LIB_DEVICETABLES_DT_GPIO_H_
#define OPENTITAN_SW_DEVICE_LIB_DEVICETABLES_DT_GPIO_H_

#include <stdint.h>

#include "sw/device/lib/devicetables/dt_api.h"

typedef enum {
  kDtGpioRegBlockCore = 0,
  kDtGpioRegBlockCount = 1,
} dt_gpio_reg_block_t;

typedef enum {
  kDtGpioIrqTypeGpio0 = 0,
  kDtGpioIrqTypeGpio1 = 1,
  kDtGpioIrqTypeGpio2 = 2,
  kDtGpioIrqTypeGpio3 = 3,
  kDtGpioIrqTypeGpio4 = 4,
  kDtGpioIrqTypeGpio5 = 5,
  kDtGpioIrqTypeGpio6 = 6,
  kDtGpioIrqTypeGpio7 = 7,
  kDtGpioIrqTypeGpio8 = 8,
  kDtGpioIrqTypeGpio9 = 9,
  kDtGpioIrqTypeGpio10 = 10,
  kDtGpioIrqTypeGpio11 = 11,
  kDtGpioIrqTypeGpio12 = 12,
  kDtGpioIrqTypeGpio13 = 13,
  kDtGpioIrqTypeGpio14 = 14,
  kDtGpioIrqTypeGpio15 = 15,
  kDtGpioIrqTypeGpio16 = 16,
  kDtGpioIrqTypeGpio17 = 17,
  kDtGpioIrqTypeGpio18 = 18,
  kDtGpioIrqTypeGpio19 = 19,
  kDtGpioIrqTypeGpio20 = 20,
  kDtGpioIrqTypeGpio21 = 21,
  kDtGpioIrqTypeGpio22 = 22,
  kDtGpioIrqTypeGpio23 = 23,
  kDtGpioIrqTypeGpio24 = 24,
  kDtGpioIrqTypeGpio25 = 25,
  kDtGpioIrqTypeGpio26 = 26,
  kDtGpioIrqTypeGpio27 = 27,
  kDtGpioIrqTypeGpio28 = 28,
  kDtGpioIrqTypeGpio29 = 29,
  kDtGpioIrqTypeGpio30 = 30,
  kDtGpioIrqTypeGpio31 = 31,
  kDtGpioIrqTypeCount = 32,
} dt_gpio_irq_type_t;

typedef enum {
  kDtGpioClockClk = 0,
  kDtGpioClockCount = 1,
} dt_gpio_clock_t;

typedef enum {
  kDtGpioPinGpio0 = 0,
  kDtGpioPinGpio1 = 1,
  kDtGpioPinGpio2 = 2,
  kDtGpioPinGpio3 = 3,
  kDtGpioPinGpio4 = 4,
  kDtGpioPinGpio5 = 5,
  kDtGpioPinGpio6 = 6,
  kDtGpioPinGpio7 = 7,
  kDtGpioPinGpio8 = 8,
  kDtGpioPinGpio9 = 9,
  kDtGpioPinGpio10 = 10,
  kDtGpioPinGpio11 = 11,
  kDtGpioPinGpio12 = 12,
  kDtGpioPinGpio13 = 13,
  kDtGpioPinGpio14 = 14,
  kDtGpioPinGpio15 = 15,
  kDtGpioPinGpio16 = 16,
  kDtGpioPinGpio17 = 17,
  kDtGpioPinGpio18 = 18,
  kDtGpioPinGpio19 = 19,
  kDtGpioPinGpio20 = 20,
  kDtGpioPinGpio21 = 21,
  kDtGpioPinGpio22 = 22,
  kDtGpioPinGpio23 = 23,
  kDtGpioPinGpio24 = 24,
  kDtGpioPinGpio25 = 25,
  kDtGpioPinGpio26 = 26,
  kDtGpioPinGpio27 = 27,
  kDtGpioPinGpio28 = 28,
  kDtGpioPinGpio29 = 29,
  kDtGpioPinGpio30 = 30,
  kDtGpioPinGpio31 = 31,
  kDtGpioPinCount = 32,
} dt_gpio_pinctrl_t;

typedef struct dt_gpio {
  dt_device_id_t device_id;
  uint32_t base_addrs[kDtGpioRegBlockCount];
  uint32_t irqs[kDtGpioIrqTypeCount];
  dt_clock_t clocks[kDtGpioClockCount];
  dt_pin_t pins[kDtGpioPinCount];
} dt_gpio_t;

/**
 * Convert a global IRQ ID to a local gpio IRQ type.
 *
 * @param dt Pointer to an instance of gpio.
 * @param irq A global IRQ ID.
 * @return The local gpio IRQ type of this irq.
 *
 * IMPORTANT This function assumes that the global IRQ belongs to the instance
 * of gpio passed in parameter. In other words, it must be the case that
 * `dt->device_id == dt_irq_to_device(irq)`
 *
 * FIXME How should we handle errors (when the invariant above is violated)?
 */
static inline dt_gpio_irq_type_t dt_gpio_irq_type(const dt_gpio_t *dt,
                                                  dt_irq_t irq) {
  // FIXME Should check that irq >= dt->irqs[0] and irq < dt->irqs[0] +
  // kDtGpioIrqTypeCount
  return irq - dt->irqs[0];
}

#endif  // OPENTITAN_SW_DEVICE_LIB_DEVICETABLES_DT_GPIO_H_
